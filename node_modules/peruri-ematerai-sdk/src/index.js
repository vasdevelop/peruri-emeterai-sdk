require('dotenv').config()
const walletSDK = require("@dattabot-blockchain/cgen-wallet")
const genSDK = require("@dattabot-blockchain/geneth-tx");
const Web3 = require("web3");
const hns = require('./hns.json');

module.exports = class eMaterai {
    constructor(stage) {
        this._ensAddress = process.env['ENS_ADDRESS'] || '0xD712CF6D5ADd6ddee0F3CEfF9FEde7c7CB4e8412';
        this.rpc = process.env['RPC'] || 'https://net.haratoken.app';
        this.web3 = new Web3(this.rpc);
        this.materaiTokenHns = hns[stage].materaiToken;
        this.materaiInfoHns = hns[stage].materaiInfo;
        this.hartHns = hns[stage].hart;
        this.wallet;
        this.seed;
        this.gentx = new genSDK(this._ensAddress);
        this.gentx.setGasLimit(1000000000)
    }

    async setWallet(seed) {
        if (this.seed != seed) {
            this.wallet = walletSDK(seed);
        }
    }
    // CALL
    // GET ETHEREUM ADDRESS, output is string: 0x1E70b41775FC70E16b5f4FD85e9675ed879CDbC8
    async getAddress(seed) {
        await this.setWallet(seed);
        try {
            let address = await this.wallet.getAddress();
            return address;
        }
        catch (err) {
            throw new Error(`Something's wrong with method getAddress(), here's why: \n ${err}`);
        }
    }
    // CALL
    // GET MATERAI BALANCE, output is number: 100
    async getMateraiBalance(address) {
        await this.setWallet("");
        try {
            let materaiBalance = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'getBalance',
                callback: this.wallet,
                params: [address]
            })
            return Number(materaiBalance.result)
        }
        catch (err) {
            throw new Error(`Something's wrong with method getMateraiBalance(), here's why: \n ${err}`);
        }
    }
    // TRANSACT
    // TRANSFER MATERAI TO BOTTOM LEVEL USER, output is string: 0x91442b644ebbefd4be78bf231c84b09ccec8342fd50c125fefdcbbe7a56a824c
    async transferMaterai(seed, to, amount) {
        await this.setWallet(seed);
        try {
            let transferTxHash = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'transfer',
                callback: this.wallet,
                params: [to, amount]
            })
            let receipt = await this.gentx.getTransactionReceipt(transferTxHash.txHash);
            let status = receipt.status;
            return {
                txHash: transferTxHash.txHash,
                status: status
            }
        }
        catch (err) {
            throw new Error(`Something's wrong with method transferMaterai(), here's why: \n ${err}`)
        }
    }
    // TRANSACT
    // PUBLISH NEW SETS OF MATERAI FROM SUPER ADMIN, output is string: 0x91442b644ebbefd4be78bf231c84b09ccec8342fd50c125fefdcbbe7a56a824c
    async mintMaterai(seed, to, amount) {
        await this.setWallet(seed);
        try {
            let mintTxHash = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'mint',
                callback: this.wallet,
                params: [to, amount]
            })
            let receipt = await this.gentx.getTransactionReceipt(mintTxHash.txHash);
            let status = receipt.status;
            return {
                txHash : mintTxHash.txHash,
                status : status
            }
        }
        catch (err) {
            throw new Error(`Something's wrong with method mintMaterai(), here's why: \n ${err}`)
        }
    }

    
    chunkArray(myArray, chunk_size){
        var results = [];   
        while (myArray.length) {
            results.push(myArray.splice(0, chunk_size));
        }
        return results;
    }
    // TRANSACT
    // MATERAI BEING USED
    async useMaterai(seed, listObjDoc, orgName, useOrgBalance){

        let listTxHash = [];
        let listIssuedId = [];
        let tokenUsed = 0;
        let data;
        let split = 500
        if(listObjDoc.length <= split){
            data = await this.useMateraiInternal(seed, listObjDoc,orgName,useOrgBalance)
            listTxHash.push({ txHash: data.txHash,status : data.status});
            listIssuedId=listIssuedId.concat(data.listIssuedId);
            tokenUsed= tokenUsed + Number(data.tokenUsed);

        }
        else if(listObjDoc.length > split){
            
            let arrayChunk = this.chunkArray(listObjDoc,split)

            for(let i=0; i<arrayChunk.length; i++){
                data = await this.useMateraiInternal(seed, arrayChunk[i])
                listTxHash.push({ txHash: data.txHash, status : data.status});
                listIssuedId=listIssuedId.concat(data.listIssuedId);
                tokenUsed= tokenUsed + Number(data.tokenUsed);
                    
            }


        }
        return {
            listTxHash      :listTxHash,
            listIssuedId    :listIssuedId,
            tokenUsed       :tokenUsed
        }

    }
    // TRANSACT
    async useMateraiInternal(seed, listObjDoc,orgName,useOrgBalance) {
        await this.setWallet(seed);

        let paramArray =  [];
        for(let i=0 ; i< listObjDoc.length; i++){
            paramArray.push(new Array(listObjDoc[i].materaiType, listObjDoc[i].docHash, listObjDoc[i].docSign));
        }
        
        try {
            let usedTxHash = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'useMaterai',
                callback: this.wallet,
                params: [paramArray,orgName,useOrgBalance]
            })

            let receipt = await this.gentx.getTransactionReceipt(usedTxHash.txHash);
            let status = receipt.status;
            let lengthLog = receipt.logs.length;
            
            const abiLog =[
                {
                    indexed: true,
                    internalType: "address",
                    name: "issuer",
                    type: "address"
                },
                {
                    indexed: true,
                    internalType: "address",
                    name: "materaiAddr",
                    type: "address"
                },
                {
                    indexed: false,
                    internalType: "bytes32[]",
                    name: "allIssuedId",
                    type: "bytes32[]"
                },
                {
                    indexed: false,
                    internalType: "uint256",
                    name: "tokenAmount",
                    type: "uint256"
                }
            ]
            const data = receipt.logs[lengthLog -1].data;
            const topics = receipt.logs[lengthLog -1].topics.slice(1);
            const decode = await this.web3.eth.abi.decodeLog(abiLog,data,topics);
            
            return {
                txHash          : usedTxHash.txHash,
                status          : status,
                listIssuedId    : decode.allIssuedId,
                tokenUsed       : decode.tokenAmount
            }
        }
        catch (err) {
            
            throw new Error(`Something's wrong with method useMaterai(), here's why: \n ${err}`)
        }
    }
    // TRANSACT
    // UPDATE DOC HASH AFTER COMBINE WITH ISSUED ID
    async updateDocHash(seed, listObjDoc){
        let listTxHash = [];
        let data;
        let split = 500
        if(listObjDoc.length <= split){

            data = await this.updateDocHashInternal(seed, listObjDoc)
            listTxHash.push({txHash: data.txHash, status: data.status});
        }
        else if(listObjDoc.length > split){

            let arrayChunk = this.chunkArray(listObjDoc,split)
            for(let i=0; i<arrayChunk.length; i++){
                data = await this.updateDocHashInternal(seed, arrayChunk[i])
                listTxHash.push({txHash: data.txHash, status: data.status});
            }
        }
        return listTxHash;
    }
    // TRANSACT
    async updateDocHashInternal(seed, listObjDoc) {
        await this.setWallet(seed);

        let paramArray =  [];
        for(let i=0 ; i< listObjDoc.length; i++){
            paramArray.push(new Array(listObjDoc[i].issuedId,listObjDoc[i].docHashAfter));
        }
        
        try {
            let updatetxHash = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'updateDocHashAfter',
                callback: this.wallet,
                params: [paramArray]
            })

            let receipt = await this.gentx.getTransactionReceipt(updatetxHash.txHash);
            let status = receipt.status;
            return {
                txHash      : updatetxHash.txHash,
                status      : status
            }
        }
        catch (err) {
            throw new Error(`Something's wrong with method updateDocHash(), here's why: \n ${err}`)
        }
    }
    //GET DETAIL ISSUED ID
    async getDetailIssuedId(issuedId) {
        await this.setWallet("");
        try {
            let detail = await this.gentx.fetch({
                uri: this.materaiInfoHns,
                fn: 'getIssuedMaterai',
                callback: this.wallet,
                params: [issuedId]
            })
            
            return {
                issuer          : detail.result.issuer,
                docHashBefore   : detail.result.docHashBefore,
                docHashAfter    : detail.result.docHashAfter,
                docSign         : detail.result.docSign,
                timestamp       : Number(detail.result.timestamp)

            }
        }
        catch (err) {
            throw new Error(`Something's wrong with method getDetailIssuedId(), here's why: \n ${err}`)
        }
    }

    //GET VERIFY DOCUMENT
    async getVerifyDocument(issuedId, docHash){
        let issuedIdData= await this.getDetailIssuedId(issuedId);
        if(docHash == issuedIdData.docHashBefore || docHash == issuedIdData.docHashAfter){
            return true;  
        }
        else{
            return false;  
        } 
    }
    //GET STATUS OF TX HASH
    async getStatusTXHash(txHash){
        await this.setWallet("");
            let receipt = await this.web3.eth.getTransactionReceipt(txHash);
            if(receipt != null){
                return receipt.status;
            }
            else{
                return false;
            }
    }
    // TRANSACT
    // CREATE NEW TRANSACTION, ADDING MEDIATOR, output string: 0x91442b644ebbefd4be78bf231c84b09ccec8342fd50c125fefdcbbe7a56a824c
    async newOrder(seed, id, seller, amount, expired) {
        await this.setWallet(seed);
        try {
            let hexedId = this.web3.utils.toHex(id).padEnd(66, "0")
            let newTxHash = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'proposeTransaction',
                callback: this.wallet,
                params: [hexedId, seller, amount, expired]
            })
            let receipt = await this.gentx.getTransactionReceipt(newTxHash.txHash);
            let status = receipt.status;
            return {
                txHash: newTxHash.txHash,
                status: status
            }
            
        }
        catch (err) {
            throw new Error(`Something's wrong with method newOrder(), here's why: \n ${err}`)
        }
    }
    // TRANSACT
    // ACTUALLY SEND MATERAI TO BUYER, output string: 0x91442b644ebbefd4be78bf231c84b09ccec8342fd50c125fefdcbbe7a56a824c
    async confirmOrder(seed, id) {
        await this.setWallet(seed);
        try {
            let hexedId = this.web3.utils.toHex(id).padEnd(66, "0")
            let confirmTxHash = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'confirmTransaction',
                callback: this.wallet,
                params: [hexedId, Date.now()]
            })
            let receipt = await this.gentx.getTransactionReceipt(confirmTxHash.txHash);
            let status = receipt.status;
            return {
                txHash: confirmTxHash.txHash,
                status: status
            }
            
        }
        catch (err) {
            throw new Error(`Something's wrong with method confirmOrder(), here's why: \n ${err}`);
        }
    }
    // TRANSACT
    // BUYER WANTS TO CANCEL, output string: 0x91442b644ebbefd4be78bf231c84b09ccec8342fd50c125fefdcbbe7a56a824c
    async cancelOrder(seed, id) {
        await this.setWallet(seed);
        try {
            let hexedId = this.web3.utils.toHex(id).padEnd(66, "0")
            let cancelTxHash = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'cancelTransaction',
                callback: this.wallet,
                params: [hexedId]
            })
            let receipt = await this.gentx.getTransactionReceipt(cancelTxHash.txHash);
            let status = receipt.status;
            return {
                txHash: cancelTxHash.txHash,
                status: status
            }
            
        }
        catch (err) {
            throw new Error(`Something's wrong with method cancelOrder(), here's why: \n ${err}`)
        }
    }
    // TRANSACT
    // CANCEL BY ADMIN, output string: 0x91442b644ebbefd4be78bf231c84b09ccec8342fd50c125fefdcbbe7a56a824c
    async releaseOrder(seed, id) {
        await this.setWallet(seed);
        try {
            let hexedId = this.web3.utils.toHex(id).padEnd(66, "0")
            let releaseTxHash = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'releaseTransaction',
                callback: this.wallet,
                params: [hexedId]
            })
            let receipt = await this.gentx.getTransactionReceipt(releaseTxHash.txHash);
            let status = receipt.status;
            return {
                txHash: releaseTxHash.txHash,
                status: status
            }
            
        }
        catch (err) {
            throw new Error(`Something's wrong with method releaseOrder(), here's why: \n ${err}`)
        }
    }
    // CALL
    async getOrderDetail(id) {
        await this.setWallet("");
        let hexedId = this.web3.utils.toHex(id).padEnd(66, "0")
        try {
            let materaiDetail = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'getTransactionDetail',
                callback: this.wallet,
                params: [hexedId]
            })
            return {
                "from": materaiDetail.result.from,
                "to": materaiDetail.result.to,
                "qty": Number(materaiDetail.result.value),
                "status": Number(materaiDetail.result.status),
                "expTime": Number(materaiDetail.result.exp)
            }
        }
        catch (err) {
            throw new Error(`Something's wrong with method getOrderDetail(), here's why: \n ${err}`)
        }
    }
    // CALL
    // GET MATERAI THAT CURRENTLY ON HOLD, output number: 99
    async getHoldMaterai(address) {
        await this.setWallet("");
        try {
            let holdMaterai = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'getHoldMaterai',
                callback: this.wallet,
                params: [address]
            })
            return Number(holdMaterai.result)
        }
        catch (err) {
            throw new Error(`Something's wrong with method getHoldMaterai(), here's why: \n ${err}`)
        }
    }
    // CALL
    // GET MATERAI THAT ALREADY SOLD, output number: 99
    async getSoldMaterai(address, time) {
        await this.setWallet("");
        try {
            let soldMaterai = await this.gentx.fetch({
                uri: this.materaiTokenHns,
                fn: 'getSoldMaterai',
                callback: this.wallet,
                params: [address, time]
            })
            return Number(soldMaterai.result)
        }
        catch (err) {
            throw new Error(`Something's wrong with method getSoldMaterai(), here's why: \n ${err}`)
        }
    }
    // CALL
    // GETSIGNED MESSAGE BY USER, output string: 0x60ee4d8bc7211deb21e737e1b073344598c48e6328c7ef9afd209a5879703d9d0a85e800d6a053e0748dd5528a0158dfd7245097e231b123d11512999d7215871c
    async signMessage(seed, message) {
        await this.setWallet(seed);
        try {

            let signedMsg = await this.wallet.getSign(message);
            return signedMsg.signature;
        }
        catch (err) {
            throw new Error(`Something's wrong with method signMessage(), here's why: \n ${err}`)
        }
    }
    // CALL
    // GET HART BALANCE, output is number: 100
    async getHartBalance(address) {
        await this.setWallet("");
        try {
            let hartBalance = await this.gentx.fetch({
                uri: this.hartHns,
                fn: 'balanceOf',
                callback: this.wallet,
                params: [address]
            })
            //convert to decimal 18
            return Number(this.web3.utils.fromWei(hartBalance.result, 'ether'))
            
            
        }
        catch (err) {
            throw new Error(`Something's wrong with method getHartBalance(), here's why: \n ${err}`);
        }
    }
    // TRANSACT
    // TRANSFER HART TO BOTTOM LEVEL USER, output is string: 0x91442b644ebbefd4be78bf231c84b09ccec8342fd50c125fefdcbbe7a56a824c
    async transferHart(seed, to, amount) {
        await this.setWallet(seed);
        //convert to decimal 18
        try {
            let transferTxHash = await this.gentx.fetch({
                uri: this.hartHns,
                fn: 'transfer',
                callback: this.wallet,
                params: [to, this.web3.utils.toWei(amount.toString(), 'ether')]
            })
            let receipt = await this.gentx.getTransactionReceipt(transferTxHash.txHash);
            let status = receipt.status;
            return {
                txHash: transferTxHash.txHash,
                status: status
            }
        }
        catch (err) {
            throw new Error(`Something's wrong with method transferHart(), here's why: \n ${err}`)
        }
    }

    // async getOrgMateraiBalance(address) {
    //     await this.setWallet("");
    //     try {
    //         let materaiBalance = await this.gentx.fetch({
    //             uri: this.materaiTokenHns,
    //             fn: 'getOrgBalance',
    //             callback: this.wallet,
    //             params: [address]
    //         })
    //         return Number(materaiBalance.result)
    //     }
    //     catch (err) {
    //         throw new Error(`Something's wrong with method getMateraiBalance(), here's why: \n ${err}`);
    //     }
    // }
}