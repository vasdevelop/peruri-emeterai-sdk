let Web3 = require("web3");
let ENS = require('ethereum-ens');
const chains = require('./chainID.json');

module.exports = class GeneralizeSDK {
    constructor(_ensAddress, _rpc){
        if (!_ensAddress && process.env['ENS_ADDRESS']){
            _ensAddress = process.env['ENS_ADDRESS'];
        }
        if (!_ensAddress){
            _ensAddress='0xD712CF6D5ADd6ddee0F3CEfF9FEde7c7CB4e8412';
        }
        this.ensAddress = _ensAddress;
        this.hnsCache={};
        if(!_rpc && process.env['RPC']){
            _rpc = process.env['RPC']
        }
        this.rpc = _rpc;
        if (!this.rpc){
            this.rpc = 'https://net.haratoken.app';
        }
        this.web3 = new Web3(this.rpc);
        this.web3Priv = new Web3(this.rpc);
        this.chainID=false;
        this.gasPrice = 10;
        this.gasLimit = 0;  //default not set
    }

    async setGasLimit(newGasLimit){
        this.gasLimit = newGasLimit;
    }

    async setRPC(newRPC, chainID = false, gasPrice = false){
        try{
            this.rpc = newRPC;
            this.web3 = new Web3(this.rpc);
            this.web3Priv = new Web3(this.rpc);
            if(chainID) this.chainID = chainID;
            if(gasPrice) this.gasPrice = gasPrice;
        }catch(e){
            console.log(e);
            return false;
        }
        return this.web3;
    }

    //get Chain ID according to defined RPC or current RPC to sign tx
    async getChainId(rpc = ''){
        if(this.chainID) return this.chainID
        if(!rpc) rpc = this.rpc;
        for(let chainKey in chains){
            if (rpc.includes(chainKey)){
                return chains[chainKey];
            }
        }
        return false;
    }

    async getHns(name, type, params){
        let ens = new ENS(this.web3Priv, this.ensAddress);
        var a = await ens.resolver(name);
        
        if(type == 'ABI' && !params){
            params = ["1"];            
        }
        if(!params) params = [];
        let res = await a[type](...params);
        if(type == 'ABI'){
            res = res['1'];
        }
        if(res.startsWith && res.startsWith('0x') && type!='addr'){
            res = this.web3.utils.toUtf8(res);
        }
        
        if(type == 'ABI') res = JSON.parse(res);
        return res;
    }

    async getContractInstance(name, addr = ''){
        if (!addr) addr = await this.getHns(name, 'addr');
        let ABI = await this.getHns(name, 'ABI' );
        return new this.web3.eth.Contract(ABI, addr);
    }

    async contract(name, addr, callback){
        if(!addr) {
            let tempAddr = name + '#addr';
            if (this.hnsCache[tempAddr]  ){
                addr = this.hnsCache[tempAddr];
            } else {
                addr = await this.getHns(name,'addr');
                this.hnsCache[tempAddr] = addr;
            }
        }
        let ABI;
        let tempABI = name + '#ABI';
        
        if ( this.hnsCache[tempABI]  ){
            ABI = this.hnsCache[tempABI];
        } else {
            ABI = await this.getHns(name,'ABI');
            this.hnsCache[tempABI] = ABI;
        }
        
        let res = {
            __ABI: ABI,
            __addr: addr,
            __SDK: this,
            __callback: callback,
            chainId: await this.getChainId(),
            __gasLimit:this.gasLimit,
            contract: new this.web3.eth.Contract(ABI,addr)
        };
        
        for(let x of ABI){
            if(x.type == 'function'){
                res[x.name] = async function (...args){
                    if(!args)args=[];
                    for(const [i,input] of x.inputs.entries()){
                        if(input.type=='address' && !args[i].startsWith('0x'))
                            if(this.__SDK.hnsCache[ args[i]+'#addr'  ]  )
                                args[i] = this.__SDK.hnsCache[ args[i]+'#addr' ].addr;
                            else{
                                let resolved = await this.__SDK.getHns(args[i],'addr');
                                this.__SDK.hnsCache[ args[i]+'#addr' ] = resolved;
                                args[i] = resolved;
                            }
                    }
                    if(x.stateMutability == 'view' || x.stateMutability == 'pure'){
                        let fromAddress;
                        if (this.__callback){
                            fromAddress = await this.__callback.getAddress();//needs documentation
                        }else {
                            fromAddress = null;
                        }
                        
                        return new Promise( (resolve,reject) => {
                            if (fromAddress) return this.contract.methods[x.name](...args).call({from:fromAddress}).then(data=>{
                                let result = {
                                    "result": data
                                }
                                resolve(result);
                            });

                            return this.contract.methods[x.name](...args).call().then(data=>{
                                let result = {
                                    "result": data
                                }
                                resolve(result);
                            });
                        });
                    }
                    else {
                        let fromAddress = await this.__callback.getAddress();//needs documentation
                        let txHash, result;
                        let promiseRes;

                        await this.__SDK.web3.eth.getTransactionCount( fromAddress ).then( async (count)=>{
                            
                            
                            let pending = await this.__SDK.web3.eth.getTransactionCount(fromAddress,"pending");
                            
                            if(count < pending){
                                count = pending + 1
                            }
                            
                            let data = await this.contract.methods[x.name](...args).encodeABI();
                            let gasLimit;
                            let tempTx={
                                to: this.__addr,
                                gasPrice: this.__SDK.web3.utils.toHex(this.__SDK.web3.utils.toWei('10', 'gwei')),
                                data: data,
                                nonce: count,
                            }
                                                        
                            try{
                                if(this.gasLimit == 0){
                                    gasLimit = await this.__SDK.web3.eth.estimateGas(tempTx);
                                }
                                if(this.gasLimit != 0){
                                    gasLimit = this.__gasLimit;
                                }
                                
                            }catch(err){
                                gasLimit = 30000000;
                            }

                            let tx = {
                                from: fromAddress,
                                to: this.__addr,
                                nonce: count,
                                data: data,
                                // gasPrice: '1',
                                gasPrice: '100000',
                                gasPrice: this.__SDK.web3.utils.toHex(this.__SDK.web3.utils.toWei('0', 'wei')),
                                gasLimit: gasLimit + 1000000,
                                chainId: this.chainId
                            };
                            let signedTx;
                            try{
                                if(tx.chainId != 1212 && tx.chainId != 2121 && this.__SDK.gasPrice != 0) tx.gasPrice = this.__SDK.web3.utils.toHex(this.__SDK.web3.utils.toWei('10', 'gwei'));
                                signedTx = await this.__callback.sign(tx); //needs documentation
                            }catch(err){
                                result = err;
                            }
                            this.__SDK.web3.eth.handleRevert = true

                            txHash = this.__SDK.web3.utils.sha3(signedTx);                            
                            result = this.__SDK.web3.eth.sendSignedTransaction(signedTx);
                            let limitNonce = tx.nonce + 10;
                            while(tx.nonce < limitNonce){

                                promiseRes = await new Promise( (resolve,reject) => {
                                    result.once('confirmation', function(confNumber, receipt){
                                        //if (receipt.status==false) return; //if something's wrong happen
                                        if(receipt.status==true){
                                            let result = {
                                                "txHash":txHash
                                            }
                                            resolve(result);
                                            return
                                        }
                                        
                                    }).on('error', function(error){
                                        if (
                                               error.toString() === 'Error: Returned error: replacement transaction underpriced' 
                                            || error.toString().includes("already known") 
                                            || error.toString().includes("nonce too low") 

                                            ){
                                            console.log("Error 1")
                                            resolve('loop');
                                        }
                                        if(error.toString().includes("reverted")){
                                            //console.log(error);
                                            console.log("Error 2");
                                            let errorRevert = {
                                                txHash  : txHash,
                                                error   : "reverted"
                                            }
                                            
                                            resolve(JSON.stringify(errorRevert));
                                    
                                        }

                                        reject(error);
                                    })
                                    return;
                                });

                                if (promiseRes.toString().includes("reverted")){
                                    let resError = await this.__SDK.getRevertReason(promiseRes)
                                    console.log("Error 2:  ", resError);
                                    throw resError;
                                }
                                
                                if (promiseRes != 'loop') break
                                    
                                let currentNonce = await this.__SDK.web3.eth.getTransactionCount(fromAddress);
                                let pendingNonce = await this.__SDK.web3.eth.getTransactionCount(fromAddress,"pending");
                                
                                if(tx.nonce < limitNonce){
                                    if(currentNonce < pendingNonce){
                                        
                                        tx.nonce = pendingNonce + 1;
                                    }
                                    
                                    if(currentNonce == pendingNonce){
                                        
                                        tx.nonce = currentNonce + 1
                                        
                                    }
                                }
                                if(tx.nonce == limitNonce){
                                    console.log("A")
                                    tx.nonce = pendingNonce +1
                                    limitNonce = pendingNonce + 10
                                }
                                   

                                
                                signedTx = await this.__callback.sign({...tx, nonce:  this.__SDK.web3.utils.toHex(tx.nonce)}); 
                                txHash = this.__SDK.web3.utils.sha3(signedTx);
                                result = this.__SDK.web3.eth.sendSignedTransaction(signedTx);
                            }
                        });
                        return promiseRes
                    }
                };
            }else if(x.type == 'event'){
                
            }
        }
        return res;
    }


    async getRevertReason(errJsonStr){
        try {
            if(errJsonStr.toString().includes("reverted")){

                let obj = JSON.parse(errJsonStr);
                let txHash= obj.txHash;
                //console.log(txHash)
                const tx = await this.web3.eth.getTransaction(txHash)
                console.log(tx)

                var result = await this.web3.eth.call(tx, tx.blockNumber)
                
                result = result.startsWith('0x') ? result : `0x${result}`
                //console.log(result)
                
                if (result && result.substr(138)) {
            
                const reason = this.web3.utils.toAscii("0x"+result.substr(138))
                
                return 'Revert reason: ' + reason +"\n" + JSON.stringify(tx)
            
                } 
                else {

                return 'Cannot get reason - No return value' +"\n" + JSON.stringify(tx);
            
                }
            }
            else{
                return err;
            }
        }
        catch(err){
            //console.log(err)
            return err;
        }
      
    }


    async fetch(uri,fn,callback,addr = '',...params){
        //name@addr/function
        let ss;
        if(typeof uri == "object"){
            ss = uri.uri;
            if(uri.fn) 
                fn = uri.fn
            else{
                ss = ss.split('/');
                fn = ss[1];
                ss = ss[0];
            }
            callback = uri.callback;
            params = uri.params;
            addr = uri.addr;
        }else if(typeof fn == "string"){
            ss = uri;
        }else if(typeof fn == 'function' || fn == null || typeof fn == "undefined"){

            if(typeof params == "undefined")params = [callback];
            else params = [callback, ...params];

            ss = uri.split('/');
            callback = fn;
            fn = ss[1];
            ss = ss[0];
        }
        //throw
        ss = ss.split('@');
        let ctr = await this.contract(ss[0],addr, callback);
        return ctr[fn](...params);
    }

    async getTransactionReceipt(txHash){
        let receipt = null;
        while(receipt==null || receipt==undefined){
            receipt = await this.web3.eth.getTransactionReceipt(txHash);
        }
        return receipt;
    }

    async getTransaction(txHash){
        let result;
        try{
            result = await this.web3.eth.getTransaction(txHash);
        }catch(e){
            console.log(e, 'error at getting transaction');
            result = false;
        }
        return result;
    }

    async getPastEvents( uri ,eventName, filter ){
        let tempAddr = uri + '#addr', addr;
        if (this.hnsCache[tempAddr]){
            addr = this.hnsCache[tempAddr];
        } else {
            addr = await this.getHns(uri,'addr');
            this.hnsCache[tempAddr] = addr;
        }
        let ABI;
        let tempABI = uri + '#ABI';
        if ( this.hnsCache[tempABI]  ){
            ABI = this.hnsCache[tempABI];
        } else {
            ABI = await this.getHns(uri,'ABI');
            this.hnsCache[tempABI] = ABI;
        }
        let contract = new this.web3.eth.Contract(ABI, addr);
        return contract.getPastEvents(eventName,{
            filter:{ filter },
            fromBlock:0,
            toBlock: 'latest'
        })
    }

}